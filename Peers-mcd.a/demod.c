/* MODIFIED CLAUSE DIFFUSION theorem prover */

#include "Header.h"
#include "Unify.h"
#include "Index.h"

/*************
 *
 *    struct term *apply_demod(term, context) -- Apply a substitution.
 *
 *    Apply always succeeds and returns a pointer to the
 *    instantiated term.
 *
 *************/

struct term *apply_demod(t, c)
struct term *t;
struct context *c;
{
    struct term *t2;
    struct rel *r1, *r2, *r3;

    DEREFERENCE(t, c)

    /* A NULL context means that the subst was generated by match. */
    /* If the context is NULL, then apply_demod just copies the term.    */
    
    t2 = get_term();
    t2->bits = t->bits;

    if (t->type == VARIABLE) {  /* variable */
	t2->type = VARIABLE;
	if (c == NULL)
	    t2->varnum = t->varnum;
	else
	    t2->varnum = c->multiplier * MAX_VARS + t->varnum;
	return(t2);
	}
    else if (t->type == NAME) {  /* name */
	t2->type = NAME;
	t2->sym_num = t->sym_num;
	return(t2);
	}
    else {  /* complex term */
	t2->type = COMPLEX;
	t2->sym_num = t->sym_num;
	r3 = NULL;
	r1 = t->farg;
	while (r1 != NULL ) {
	    r2 = get_rel();
	    if (r3 == NULL)
		t2->farg = r2;
	    else
		r3->narg = r2;
	    r2->argval = apply_demod(r1->argval, c);
	    r3 = r2;
	    r1 = r1->narg;
	    }
	return(t2);
	}
}  /* apply_demod */

/*************
 *
 *    contract_bt
 *
 *************/

struct term *contract_bt(t, demods, actor_ptr)
struct term *t;
void *demods;
struct literal **actor_ptr;
{
    struct list_pos *tp;
    struct discrim_pos *pos;
    struct bt_node *bt;
    struct term *contractum, *partial, *atom;
    struct literal *demodulator;
    struct context *c;
    static int count;

#if 0
    printf("contract_bt receives "); p_term(t); printf("\n"); fflush(stdout);
#endif    
    c = get_context();
    contractum = NULL;

    if (Flags[INDEX_DEMOD].val)
	demodulator = (struct literal *) discrim_wild_retrieve_first(t, (struct discrim *) demods, &pos);
    else {
	tp = ((struct list *) demods)->first;
	demodulator = (tp ? tp->lit : NULL);
	}
	
    while (demodulator && !contractum) {
	atom = demodulator->atom;        /* demods is list of terms */
	bt = match_bt_first(atom->farg->argval, c, t, 1);
	Stats[REWRITE_ATTEMPTS]++;

	if (bt) {
	    Stats[REWRITES]++;

	    contractum = apply_demod(atom->farg->narg->argval, c);
	    if (c->partial_term) {
		/* Get copy, including marks that indicate normal terms. */
		partial = apply_demod(c->partial_term,(struct context *) NULL);
		contractum = build_binary_term(t->sym_num,contractum,partial);
		}
	    match_bt_cancel(bt);
	    if (Flags[INDEX_DEMOD].val)
		discrim_wild_cancel(pos);
	    *actor_ptr = demodulator;
	    }
	else {
	    if (Flags[INDEX_DEMOD].val)
		demodulator = (struct literal *) discrim_wild_retrieve_next(&pos);
	    else {
		tp = tp->next;
		demodulator = (tp ? tp->lit : NULL);
		}
	    }
	}
    free_context(c);
#if 0
    if (contractum) {
	printf("count=%d, t: ",count); p_term(t);
	printf("demodulator: "); p_term(atom);
	printf("contractum: "); p_term(contractum);
	printf("\n");
	fflush(stdout);
	}
#endif    
    return(contractum);
}  /* contract_bt */

/*************
 *
 *    demodulate_flat
 *
 *************/

struct term *demodulate_flat(t, demods, psn, head_ptr)
struct term *t;
void *demods;
int psn;
struct gen_ptr **head_ptr;
{
    struct rel *r;
    struct term *contractum;
    int sn;
    struct gen_ptr *p;
    struct literal *actor;

    if (t->bits == 0 && t->type != VARIABLE) {  /* improve later */
	sn = t->sym_num;
	for (r = t->farg; r; r = r->narg)
	    r->argval = demodulate_flat(r->argval, demods, sn, head_ptr);

	if (sn != psn || !is_assoc_comm(sn)) {  /* If not part of an AC term */
	    ac_canonical(t);
	    contractum = contract_bt(t, demods, &actor);
	    if (contractum) {
#if 0
		if (Stats[CLAUSES_GENERATED] == 1887) {
		    printf("\nrewriting "); print_term(stdout, t); printf(" to ");
		    print_term(stdout, contractum); printf(" with "); p_clause(actor);
		    }
#endif		
		zap_term(t);
		ac_canonical(contractum);
#if 0
		if (actor->id == 15)
		    printf("time to stop.\n");
#endif		
		if (Flags[DEMOD_HISTORY].val) {
		    p = get_gen_ptr();
		    p->u.i = actor->id;
		    p->next = *head_ptr;
		    *head_ptr = p;
		    }
		t = demodulate_flat(contractum, demods, psn, head_ptr);
		}
	    }
	}
    t->bits = 1;  /* improve later */
    return(t);
}  /* demodulate_flat */

/*************
 *
 *     clear_demod_marks(t)
 *
 *************/

void clear_demod_marks(t)
struct term *t;
{
    struct rel *r;

    t->bits = 0;
    if (t->type == COMPLEX)
	for(r = t->farg; r; r = r->narg)
	    clear_demod_marks(r->argval);
}  /* clear_demod_marks */

