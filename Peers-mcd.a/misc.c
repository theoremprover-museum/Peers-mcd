/* MODIFIED CLAUSE DIFFUSION theorem prover */

#include "Header.h"
#include "Peers.h"

/*************
 *
 *    init() -- initialize global variables
 *
 *************/

void init()
{
    int i;

    for (i=0; i<MAX_STATS; i++)
	Stats[i] = 0;
    Stats[INIT_WALL_SECONDS] = wall_seconds();
    init_avail();
    init_clocks();
    init_symbol_table();
    init_options();
    init_special_ops();
}  /* init */

/*************
 *
 *    abend
 *
 *************/

void abend(str)
char *str;
{
    output_stats(Peer_fp);
    fprintf(Peer_fp, "\n\n********** ABNORMAL END **********\n");
    fprintf(Peer_fp, "********** %s\n", str);
    fprintf(Peer_fp, "\nTHE END\n");

    fprintf(stderr, "\n\n\007********** ABNORMAL END **********\n");
    fprintf(stderr, "********** %s\n", str);

    m4_broadcast(HALT_MSG, "", 0);  /* Upon abnormal end, all peers halt. */
    p4_wait_for_end();
    exit(ABEND_EXIT);
    
}  /* abend */

/*************
 *
 *    output_stats
 *
 *************/

void output_stats(fp)
FILE *fp;
{
    print_mem(fp);
    print_stats(fp);
    print_times(fp);

}  /* output_stats */

/*************
 *
 *    print_stats(fp)
 *
 *************/

void print_stats(fp)
FILE *fp;
{
    fprintf(fp, "\n-------------- statistics -------------\n");
    
    fprintf(fp, "Input errors             %7ld\n", Stats[INPUT_ERRORS]);
    fprintf(fp, "Kbytes malloced          %7ld\n", Stats[K_MALLOCED]);
    fprintf(fp, "BT occur checks          %7ld\n", Stats[BT_OCCUR_CHECKS]);
    fprintf(fp, "Demod rewrite attempts   %7ld\n", Stats[REWRITE_ATTEMPTS]);
    fprintf(fp, "Demod rewrites           %7ld\n", Stats[REWRITES]);
    fprintf(fp, "FPA overloads            %7ld\n", Stats[FPA_OVERLOADS]);
    fprintf(fp, "FPA underloads           %7ld\n", Stats[FPA_UNDERLOADS]);
    fprintf(fp, "AC initiations           %7ld\n", Stats[AC_INITIATIONS]);
    fprintf(fp, "AC continuations         %7ld\n", Stats[AC_CONTINUATIONS]);
    fprintf(fp, "Proofs found             %7ld\n", Stats[PROOFS]);

    fprintf(fp, "Clauses or pairs given   %7ld\n", Stats[CLAUSES_GIVEN]);
    fprintf(fp, "Clauses generated        %7ld\n", Stats[CLAUSES_GENERATED]);
    fprintf(fp, "Clauses forward subsumed %7ld\n", Stats[CLAUSES_FORWARD_SUBSUMED]);
    fprintf(fp, "Clauses deleted by weight%7ld\n", Stats[CLAUSES_WT_DELETED]);
    fprintf(fp, "Clauses kept             %7ld\n", Stats[CLAUSES_KEPT]);
    fprintf(fp, "Clauses back demodulated %7ld\n", Stats[CLAUSES_BACK_DEMODULATED]);
    fprintf(fp, "\n");
    fprintf(fp, "Residents                %7ld\n", Stats[RESIDENTS]);
    fprintf(fp, "Visitors                 %7ld\n", Stats[VISITORS]);   
    fprintf(fp, "Residents in SOS         %7ld\n", Stats[RESIDENTS_IN_SOS]);
    fprintf(fp, "Visitors in SOS          %7ld\n", Stats[VISITORS_IN_SOS]);
    fprintf(fp, "Generated by expansion   %7ld\n", Stats[EXP_GENERATED]);
    fprintf(fp, "Inference msgs broadcast %7ld\n", Stats[IM_BROADCAST]);
    fprintf(fp, "Inference msgs received  %7ld\n", Stats[IM_RECEIVED]);
    fprintf(fp, "Residents back demod     %7ld\n", Stats[BD_RESIDENTS]);
    fprintf(fp, "Visitors back demod      %7ld\n", Stats[BD_VISITORS]);
    fprintf(fp, "Proof length             %7ld\n", Stats[PROOF_LENGTH]);
}  /* print_stats */

/*************
 *
 *    p_stats()
 *
 *************/

void p_stats()
{
    print_stats(stdout);
}  /* p_stats */

/*************
 *
 *    print_times(fp)
 *
 *************/

void print_times(fp)
FILE *fp;
{
    long t, min, hr;

    fprintf(fp, "\n----------- times (seconds) ----------- %s\n", get_time());

    t = run_time();
    fprintf(fp, "user time           %10.2f  ", t / 1000.);
    t = t / 1000; hr = t / 3600; t = t % 3600; min = t / 60; t = t % 60;
    fprintf(fp, " (%ld hr, %ld min, %ld sec)\n", hr, min, t); 

    t = system_time();
    fprintf(fp, "system time         %10.2f  ", t/ 1000.);
    t = t / 1000; hr = t / 3600; t = t % 3600; min = t / 60; t = t % 60;
    fprintf(fp, " (%ld hr, %ld min, %ld sec)\n", hr, min, t); 

    t = wall_seconds() - Stats[INIT_WALL_SECONDS];
    fprintf(fp, "wall-clock time     %7ld     ", t);
    hr = t / 3600; t = t % 3600; min = t / 60; t = t % 60;
    fprintf(fp, " (%ld hr, %ld min, %ld sec)\n", hr, min, t); 

    fprintf(fp, "input time          %10.2f\n", clock_val(INPUT_TIME) / 1000.);
    fprintf(fp, "demodulation time   %10.2f\n", clock_val(DEMOD_TIME) / 1000.);
    fprintf(fp, "back demod find time%10.2f\n", clock_val(BD_FIND_TIME) / 1000.);
    fprintf(fp, "LRPO time           %10.2f\n", clock_val(LRPO_TIME) / 1000.);

    fprintf(fp, "inference msg time  %10.2f\n", clock_val(INF_MSG_TIME) / 1000.);
    fprintf(fp, "inference work time %10.2f\n", clock_val(INFERENCE_TIME) / 1000.);

    fprintf(fp, "\n");
}  /* print_times */

/*************
 *
 *    p_times()
 *
 *************/

void p_times()
{
    print_times(stdout);
}  /* p_times */

/*************
 *
 *    read_preamble()
 *
 *************/

void read_preamble()
{
    struct term *t;
    int rc, error, go;

    CLOCK_START(INPUT_TIME)

    go = 1;
    t = read_term(stdin, &rc);
    while (go && t != NULL || rc == 0) {
        error = 0;
        if (t == NULL)
            error = 1;
        else if (t->type == NAME) {
	    if (str_ident("end_of_commands", sn_to_str(t->sym_num))) {
                print_term(stdout, t); printf(".\n");
		go = 0;
		}
	    else
		error = 1;
	    }
        else if (t->type != COMPLEX)
            error = 1;
        else if (str_ident("set", sn_to_str(t->sym_num))) {
            if (change_flag(stdout, t, 1)) {
                print_term(stdout, t); printf(".\n");
                }
            }
        else if (str_ident("clear", sn_to_str(t->sym_num))) {
            if (change_flag(stdout, t, 0)) {
                print_term(stdout, t); printf(".\n");
                }
            }
        else if (str_ident("assign", sn_to_str(t->sym_num))) {
            if (change_parm(stdout, t)) {
                print_term(stdout, t); printf(".\n");
                }
            }
        else if (str_ident("lex", sn_to_str(t->sym_num))) {
            print_term(stdout, t);
            printf(".\n");
            if (!process_lex_command(t))
                Stats[INPUT_ERRORS]++;
	    ;
            }
        else if (str_ident("op", sn_to_str(t->sym_num))) {
            print_term(stdout, t);
            printf(".\n");
            if (!process_op_command(t))
                Stats[INPUT_ERRORS]++;
            }
        else if (str_ident("assoc_comm", sn_to_str(t->sym_num))) {
            print_term(stdout, t);
            printf(".\n");
            if (!process_ac_command(t))
                Stats[INPUT_ERRORS]++;
	    }
        else if (str_ident("commutative", sn_to_str(t->sym_num))) {
            print_term(stdout, t);
            printf(".\n");
            if (!process_comm_command(t))
                Stats[INPUT_ERRORS]++;
            }
        else if (str_ident("lrpo_multiset_status", sn_to_str(t->sym_num))) {
            print_term(stdout, t);
            printf(".\n");
            if (!process_multiset_command(t))
                Stats[INPUT_ERRORS]++;
            }
        else
            error = 1;

        if (error) {
            Stats[INPUT_ERRORS]++;
            if (t != NULL) {
                printf("ERROR, command not found: ");
                print_term(stdout, t); printf(".\n");
                }
            }
        if (t != NULL)
            zap_term(t);
	if (go)
	    t = read_term(stdin, &rc);
        }

    CLOCK_STOP(INPUT_TIME)


}  /* read_preamble */

/*************
 *
 *    build_binary_term
 *
 *************/

struct term *build_binary_term(sn, t1, t2)
int sn;
struct term *t1;
struct term *t2;
{
    struct term *t;
    struct rel *r1, *r2;

    t = get_term();
    r1 = get_rel(); r1->argval = t1;
    r2 = get_rel(); r2->argval = t2;
    t->farg = r1;
    r1->narg = r2;
    t->type = COMPLEX;
    t->sym_num = sn;
    return(t);
}  /* build_binary_term */

/*************
 *
 *     reverse_gen_list(p1, p2)
 *
 *************/

struct gen_ptr *reverse_gen_list(p1, p2)
struct gen_ptr *p1;
struct gen_ptr *p2;
{
    struct gen_ptr *p3;

    if (!p1)
	return(p2);
    else {
	p3 = p1->next;
	p1->next = p2;
	return(reverse_gen_list(p3, p1));
	}
}  /* reverse_gen_list */

/*************
 *
 *     int occurs_in(t1, t2) -- Does t1 occur in t2?
 *
 *     term_ident is used to check identity.
 *
 *************/

int occurs_in(t1, t2)
struct term *t1;
struct term *t2;
{
    struct rel *r;

    if (term_ident(t1, t2))
	return(1);
    else if (t2->type != COMPLEX)
	return(0);
    else {
	r = t2->farg;
	while (r && !occurs_in(t1, r->argval)) 
	    r = r->narg;
	return(r != NULL);
	}
}  /* occurs_in */

/*************
 *
 *   copy_gen_ptr_list(p)
 *
 *************/

struct gen_ptr *copy_gen_ptr_list(p)
struct gen_ptr *p;     
{
    struct gen_ptr *start, *p1, *p2;

    start = NULL;
    p2 = NULL;
    for ( ; p; p = p->next) {
	p1 = get_gen_ptr();
	p1->u.v = p->u.v;
	if (p2)
	    p2->next = p1;
	else
	    start = p1;
	p2 = p1;
	}
    return(start);
}  /* copy_gen_ptr_list */
